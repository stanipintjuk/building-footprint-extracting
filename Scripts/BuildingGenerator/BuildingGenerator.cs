using System;
using UnityEngine;
using System.Collections.Generic;

public class BuildingGenerator:ThreadableI
{
	public bool generated = false;

	private Texture2D map_image;
	private Vector3 position;

	private Transform parent;

	private FootprintHandler fohand;

	private int[,] map;
	private int width;
	private int depth;

	/*
	 * Telescopic constructors start here
	 */
	public BuildingGenerator (Texture2D map_texture):this(map_texture, Vector3.zero)
	{
	}

	public BuildingGenerator (Texture2D map_texture, Vector3 pos):this(map_texture, pos, 15.0f)
	{
	}

	public BuildingGenerator (Texture2D map_texture, Vector3 pos, float threshold):this(map_texture, pos, threshold, null){}

	public BuildingGenerator (Texture2D map_texture, Vector3 pos, float threshold, Transform parent)
	{
		this.parent = parent;
		fohand = new FootprintHandler (threshold);
		map_image = map_texture;
		position = pos;
		translateMap ();
	}

	/**
	 *  calls preCalc() and afterCalc()
	 */
	public void Create(){
		preCalc ();
		afterCalc ();
	}

	/**
	 * For threading purposes. Does not use Unity API.
	 * Defenition for preCalc from ThredableI interace.
	 * 
	 * Extracts footprints using FootprintHandler.
	 */
	public void preCalc(){
		fohand.createFromMap (map, width, depth);
	}

	/**
	 * Defenition for afterCalc from ThreadableI interface.
	 * Uses Unity API.
	 * 
	 * Creates GameObjects from Building's generated by FootprintHandler.
	 */
	public void afterCalc(){
		GeometryHandler gh = new GeometryHandler();		 
		foreach (Building b in fohand.buildings){
			GameObject building = gh.materializeBuilding(b, position);
			building.transform.parent = parent;
		}
		generated = true;
	}

	//Translates the Texture2D map_image to a matrix with 1's as building elements and 0's as non-building elements.
	private void translateMap(){
		//the distance between black and white
		float BWdist = Mathf.Sqrt (3);
		
		width = map_image.width;
		depth = map_image.height;
		map = new int[width, depth];
		
		for (int y = 0; y < depth; y++) {
			for (int x = 0; x < width; x++){
				Color c = map_image.GetPixel(x,y);
				Vector3 colorVec = new Vector3(c.r,c.g,c.b);
				if (colorVec.magnitude < BWdist/2.0f){
					map[x,y] = 1;
				}else{
					map[x,y] = 0;
				}
			}
		}
	}

}


